D = np.arange(15).reshape((3, 5))
print(D)

print(D.T)

E = rng.normal(0, 1, (6, 3))
E

np.dot(E[:, 0], E[:, 1]) # producto escalar de dos columnas

np.dot(E[2],E[4]) # producto escalar de dos filas

np.dot(E, E[0]) # producto de una matriz por un vector

np.dot(E.T, E)   # producto de dos matrices

A = np.arange(3*7*4*5).reshape(3, 7, 4, 5)
B = np.arange(3*7*5*6).reshape(3, 7, 5, 6)

np.dot(A, B).shape

np.matmul(A, B).shape # similar a A @ B 

M = np.arange(10)
M

np.sqrt(M) # raiz cuadrada de cada componente

np.exp(M.reshape(2,5)) # exponencial de cad componente

x = rng.normal(0, 1, 8)
y = rng.normal(0, 1, 8)
x, y

np.maximum(x, y)

x.max()

xarr = np.array([1.1, 1.2, 1.3, 1.4, 1.5])
yarr = np.array([2.1, 2.2, 2.3, 2.4, 2.5])
mask = np.array([True, False, True, True, False])

result = [(x if c else y) for x, y, c in zip(xarr, yarr, cond)]
result

result = np.where(mask, xarr, yarr)
result

F = rng.normal(0, 1, (4, 4))

F, np.where(F > 0, 2, -2)

np.where(F > 0, 2, F) 

np.select(
    [np.abs(F) > 2, np.abs(F) > 1],
    ["Poco probable", "Algo probable"], 
    "Frecuente"
)

G = rng.normal(0, 1, (5, 4))
G

G.sum()

G.mean()

G.cumsum() # por defecto, se aplana el array y se hace la suma acumulada

print(G)

G.mean(axis=1)

G.sum(axis=0)

G.cumsum(axis=0)

G, G.argmin(axis=0)

H = rng.normal(0, 1, 50)
H

(H > 0).sum() # Number of positive values

bools = np.array([False, False, True, False])
bools.any(), bools.all()

np.any(H > 0)

np.all(H < 10)

np.any(H > 15)

np.all(H > 0)

J = np.arange(10)
np.save('un_array', J)

np.load('un_array.npy')

np.savez('array_archivo.npz', a=J, b=J**2)

arch = np.load('array_archivo.npz')
arch['b']

arch['a']

list(arch)

np.savez_compressed('arrays_comprimidos.npz', a=J, b=J**2)

!ls -lah

!rm un_array.npy
!rm array_archivo.npz
!rm arrays_comprimidos.npz
